#!/usr/bin/env bash

# this script makes a backup of important files 
# in home directory. Arguments: destination folder
# the files backed up are described in
# ~/.config/backup/conf, one file/directory
# per line. The backups is done recursively.
# To avoid backing up a file/directory,
# prepend ! to that file/dir name in the config file

function usage {
    cat <<EOF

    backup [-h][-c <config>] -f <backup_file>

backup is a cli utility that does only one thing, in a very dumb way: parses
through a configuration file located in '\$HOME/.config/backup/conf' and
archives and compresses all the files and directories specified in that
configuration, and stores the result in a file of your choice. For example, if
you type:

    backup /mnt/backup_file

backup will archive and compress everyth ing specified in the configuration
file (rec ursively), and then save the archive in /mnt/backup _file. If
the configuration file or the directory do not exist, backup will prompt
just backup the entire filesystem starting from \$HOME

The configuration is very simple: a file or directory name for every line. If
you want to excl ude something from the backup that would otherwise be
included, write it like you would normally do to i nclude it, but prepend it
with a bang: '!'. That's it.

EOF
}

function parser {
    # check if conf file exists and it is not a directory
    [ -e "$1" -a ! -d "$1"  ] || return 0
    # parse the config file
    while read directory; do
        if [[ "$directory" =~ '!' ]]; then
            local not_to_backup+="-path \"*${directory:1}*\" -prune -o "
        else
            local docs_to_backup+="$directory "
        fi
    done < "$1"
    # build the commandline
    local exe="find $docs_to_backup $not_to_backup -print"
    echo $exe
}

# parse directories provided from commandline
# create a temporary conf file
function line_parser {
    echo "$1" | tr ',' "\n" > /tmp/configuration
}

# parse commandline
optstring=":hc:f:i:"
while getopts $optstring name; do
    case $name in
        h) usage; exit 0;;
        c) configuration=$OPTARG;;
        f) destination=$OPTARG;;
        i) 
            line_parser $OPTARG
            configuration="/tmp/configuration"
            ;;
        :) if [ "$OPTARG" = "c" ]; then
            echo "You need to specify a configuration file"
        elif [ "$OPTARG" = "f" ]; then
            echo "You need to specify a destination directory!"
        fi
        exit 1
        ;;
        *) echo "$OPTARG is not a valid option"; usage; exit 1;;
    esac
done

# if no config provided, stick to default
[ -z "$configuration" ] && configuration="$HOME/.config/backup/conf"
# if no destination directory provided, use HOME
[ -z "$destination" ] && destination="$HOME"

# switch to home directory
cd $HOME
# parse the configuration
exe=$( parser $configuration )
# if exe empty it means the configuration provided didn't exist
[ -z "$exe" ] && echo "The configuration doesn't exist!" && exit 1
# find all filenames to backup and not to backup,
# and save them in a temporary file
eval "$exe" > /tmp/backup
# archive name
archive="$( date +"%Y-%m-%d" )_backup.tar.gz"
# execute the backup
tar --no-recursion -cvz -T /tmp/backup -f $destination/$archive
# vim: ft=bash
